"""Repository for alert_configs table operations (API Service)."""

import json
import logging
from datetime import datetime
from typing import Any

import asyncpg

logger = logging.getLogger(__name__)


class AlertSignalRepository:
    """Repository for alert_configs table operations.

    Uses asyncpg.Pool from the shared database module.
    """

    def __init__(self, pool: asyncpg.Pool) -> None:
        """Initialize repository.

        Args:
            pool: asyncpg connection pool.
        """
        self._pool = pool

    def _row_to_dict(self, row: asyncpg.Record) -> dict[str, Any]:
        """Convert asyncpg.Record to dict, parsing JSON fields.

        Args:
            row: Database record.

        Returns:
            Dictionary with parsed JSON fields.
        """
        result = dict(row)
        # Parse JSON fields
        if "params" in result and isinstance(result["params"], str):
            result["params"] = json.loads(result["params"])
        return result

    async def create(
        self,
        alert_id: str,
        name: str,
        strategy_type: str,
        symbol: str,
        interval: str,
        trigger_type: str = "each_kline_close",
        params: dict[str, Any] | None = None,
        description: str | None = None,
        is_enabled: bool = True,
        created_by: str | None = None,
    ) -> dict[str, Any]:
        """Create a new alert signal.

        Args:
            alert_id: Alert UUID (generated by frontend).
            name: Alert name.
            strategy_type: Strategy type (e.g., macd_resonance, rsi_oversold).
            symbol: Trading pair symbol.
            interval: K-line interval (TradingView format: 1, 5, 15, 60, 240, D, W, M).
            trigger_type: Trigger type (once_only, each_kline, each_kline_close, each_minute).
            params: Strategy parameters JSON.
            description: Alert description.
            is_enabled: Whether the alert is enabled.
            created_by: Creator identifier.

        Returns:
            Created alert as a dictionary with all fields.
        """
        async with self._pool.acquire() as conn:
            row = await conn.fetchrow(
                """
                INSERT INTO alert_configs (
                    id, name, strategy_type, symbol, interval, trigger_type,
                    params, description, is_enabled, created_by
                )
                VALUES ($1, $2, $3, $4, $5, $6, $7::jsonb, $8, $9, $10)
                RETURNING id, name, strategy_type, symbol, interval, trigger_type,
                         params, description, is_enabled, created_by, created_at, updated_at
                """,
                alert_id,
                name,
                strategy_type,
                symbol,
                interval,
                trigger_type,
                json.dumps(params) if params else "{}",
                description,
                is_enabled,
                created_by,
            )
            # Convert row to dict with proper JSON parsing for params
            result = dict(row)
            if result.get("params"):
                result["params"] = json.loads(result["params"])
            if result.get("created_at"):
                result["created_at"] = result["created_at"].isoformat()
            if result.get("updated_at"):
                result["updated_at"] = result["updated_at"].isoformat()
        logger.info(
            "Alert signal created: id=%s name=%s strategy_type=%s symbol=%s interval=%s",
            result.get("id"),
            name,
            strategy_type,
            symbol,
            interval,
        )
        return result

    async def update(
        self,
        alert_id: str,
        name: str | None = None,
        description: str | None = None,
        strategy_type: str | None = None,
        symbol: str | None = None,
        interval: str | None = None,
        trigger_type: str | None = None,
        params: dict[str, Any] | None = None,
        is_enabled: bool | None = None,
    ) -> bool:
        """Update an alert signal.

        Args:
            alert_id: Alert UUID string.
            name: New name.
            description: New description.
            strategy_type: New strategy type.
            symbol: New symbol.
            interval: New interval.
            trigger_type: New trigger type.
            params: New parameters.
            is_enabled: New enabled status.

        Returns:
            Whether update was successful.
        """
        updates: list[str] = []
        values: list[Any] = []
        param_idx = 1

        if name is not None:
            updates.append(f"name = ${param_idx}")
            values.append(name)
            param_idx += 1

        if description is not None:
            updates.append(f"description = ${param_idx}")
            values.append(description)
            param_idx += 1

        if strategy_type is not None:
            updates.append(f"strategy_type = ${param_idx}")
            values.append(strategy_type)
            param_idx += 1

        if symbol is not None:
            updates.append(f"symbol = ${param_idx}")
            values.append(symbol)
            param_idx += 1

        if interval is not None:
            updates.append(f"interval = ${param_idx}")
            values.append(interval)
            param_idx += 1

        if trigger_type is not None:
            updates.append(f"trigger_type = ${param_idx}")
            values.append(trigger_type)
            param_idx += 1

        if params is not None:
            updates.append(f"params = ${param_idx}::jsonb")
            values.append(json.dumps(params))
            param_idx += 1

        if is_enabled is not None:
            updates.append(f"is_enabled = ${param_idx}")
            values.append(is_enabled)
            param_idx += 1

        if not updates:
            return False

        # Add updated_at to the SET clause
        updates.append("updated_at = NOW()")

        # Build query with alert_id as the last parameter
        query = f"""
            UPDATE alert_configs
            SET {', '.join(updates)}
            WHERE id = ${param_idx}
        """

        # Add alert_id to the end of values
        values.append(alert_id)
        async with self._pool.acquire() as conn:
            result = await conn.execute(query, *values)
        return result == "UPDATE 1"

    async def delete(self, alert_id: str) -> bool:
        """Delete an alert signal.

        Args:
            alert_id: Alert UUID.

        Returns:
            Whether deletion was successful.
        """
        async with self._pool.acquire() as conn:
            result = await conn.execute(
                "DELETE FROM alert_configs WHERE id = $1",
                alert_id,
            )
        return result == "DELETE 1"

    async def find_by_id(self, alert_id: str) -> dict[str, Any] | None:
        """Find an alert by ID.

        Args:
            alert_id: Alert UUID.

        Returns:
            Alert record dict or None.
        """
        async with self._pool.acquire() as conn:
            row = await conn.fetchrow(
                """
                SELECT id, name, description, strategy_type, symbol, interval,
                       trigger_type, params, is_enabled, created_at, updated_at, created_by
                FROM alert_configs
                WHERE id = $1
                """,
                alert_id,
            )
        if row:
            return self._row_to_dict(row)
        return None

    async def find_all(
        self,
        limit: int = 100,
        offset: int = 0,
        is_enabled: bool | None = None,
        symbol: str | None = None,
        strategy_type: str | None = None,
        created_by: str | None = None,
    ) -> tuple[list[dict[str, Any]], int]:
        """Find all alert signals with filtering and pagination.

        Args:
            limit: Maximum records to return.
            offset: Offset for pagination.
            is_enabled: Filter by enabled status.
            symbol: Filter by symbol.
            strategy_type: Filter by strategy type.
            created_by: Filter by creator.

        Returns:
            Tuple of (list of alert record dicts, total count).
        """
        conditions = []
        params: list = []
        param_idx = 1

        if is_enabled is not None:
            conditions.append(f"is_enabled = ${param_idx}")
            params.append(is_enabled)
            param_idx += 1

        if symbol is not None:
            conditions.append(f"symbol = ${param_idx}")
            params.append(symbol)
            param_idx += 1

        if strategy_type is not None:
            conditions.append(f"strategy_type = ${param_idx}")
            params.append(strategy_type)
            param_idx += 1

        if created_by is not None:
            conditions.append(f"created_by = ${param_idx}")
            params.append(created_by)
            param_idx += 1

        where_clause = f"WHERE {' AND '.join(conditions)}" if conditions else ""

        async with self._pool.acquire() as conn:
            total_row = await conn.fetchrow(
                f"""
                SELECT COUNT(*) as count
                FROM alert_configs
                {where_clause}
                """,
                *params,
            )
            total = total_row["count"] if total_row else 0

            rows = await conn.fetch(
                f"""
                SELECT id, name, description, strategy_type, symbol, interval,
                       trigger_type, params, is_enabled, created_at, updated_at, created_by
                FROM alert_configs
                {where_clause}
                ORDER BY created_at DESC
                LIMIT ${param_idx} OFFSET ${param_idx + 1}
                """,
                *params,
                limit,
                offset,
            )
        return [self._row_to_dict(row) for row in rows], total

    async def find_by_symbol_interval(
        self,
        symbol: str,
        interval: str,
    ) -> list[dict[str, Any]]:
        """Find alert signals by symbol and interval.

        Args:
            symbol: Trading pair symbol.
            interval: K-line interval.

        Returns:
            List of alert record dicts.
        """
        async with self._pool.acquire() as conn:
            rows = await conn.fetch(
                """
                SELECT id, name, description, strategy_type, symbol, interval,
                       trigger_type, params, is_enabled, created_at, updated_at, created_by
                FROM alert_configs
                WHERE symbol = $1 AND interval = $2
                ORDER BY created_at DESC
                """,
                symbol,
                interval,
            )
        return [self._row_to_dict(row) for row in rows]

    async def find_enabled(self) -> list[dict[str, Any]]:
        """Find all enabled alert signals.

        Returns:
            List of enabled alert record dicts.
        """
        async with self._pool.acquire() as conn:
            rows = await conn.fetch(
                """
                SELECT id, name, description, strategy_type, symbol, interval,
                       trigger_type, params, is_enabled, created_at, updated_at, created_by
                FROM alert_configs
                WHERE is_enabled = TRUE
                ORDER BY created_at DESC
                """,
            )
        return [self._row_to_dict(row) for row in rows]

    async def count_all(self) -> int:
        """Get total count of alert signals.

        Returns:
            Total number of alert signals.
        """
        async with self._pool.acquire() as conn:
            return await conn.fetchval(
                "SELECT COUNT(*) FROM alert_configs"
            )

    async def enable(self, alert_id: str) -> bool:
        """Enable an alert signal.

        Args:
            alert_id: Alert UUID string.

        Returns:
            Whether enable was successful.
        """
        async with self._pool.acquire() as conn:
            result = await conn.execute(
                """
                UPDATE alert_configs
                SET is_enabled = TRUE, updated_at = NOW()
                WHERE id = $1
                """,
                alert_id,
            )
        return result == "UPDATE 1"

    async def disable(self, alert_id: str) -> bool:
        """Disable an alert signal.

        Args:
            alert_id: Alert UUID string.

        Returns:
            Whether disable was successful.
        """
        async with self._pool.acquire() as conn:
            result = await conn.execute(
                """
                UPDATE alert_configs
                SET is_enabled = FALSE, updated_at = NOW()
                WHERE id = $1
                """,
                alert_id,
            )
        return result == "UPDATE 1"
